# script that pulls data from several sources and generate vulnerability breakdown for subnational SEIR model

import os
import glob
import argparse
import logging
from pathlib import Path
import ast
import itertools

import numpy as np
import pandas as pd
import geopandas as gpd
import rasterio
from rasterio.merge import merge
from rasterio.mask import mask
import fiona

import utils
from Generate_SADD_exposure_from_tiff import get_output_filename, GENDER_CLASSES, AGE_CLASSES

INPUT_DIR = 'Inputs'
OUTPUT_DIR = os.path.join('Outputs', '{}', 'Vulnerability')
OUTPUT_GEOJSON = '{country_iso3}_Vulnerabilities.geojson'
CONFIG_FILE = 'config.yml'
DIR_PATH = os.path.dirname(os.path.realpath(__file__))

# Shape stuff
SHAPEFILE_DIR = 'Shapefiles'
SHP_CRS = 'EPSG:4326'

# IPC
IPC_DIR = 'IPC'

# GHS data
GHS_DIR = 'GHS'
GHS_URL_BASE = 'https://cidportal.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL'
GHS_URL = {'SMOD': 'GHS_SMOD_POP_GLOBE_R2019A/GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K/V2-0/tiles/'
                   'GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K_V2_0_{column}_{row}.zip',
           'POP': 'GHS_POP_MT_GLOBE_R2019A/GHS_POP_E2015_GLOBE_R2019A_54009_1K/V1-0/tiles/'
                  'GHS_POP_E2015_GLOBE_R2019A_54009_1K_V1_0_{column}_{row}.zip'
           }
OUTPUT_GHS = {
    'SMOD':  '{country_iso3}_SMOD_2015_1km_mosaic.tif',
    'POP': '{country_iso3}_POP_2015_1km_mosaic.tif'
}
GHS_CRS = 'ESRI:54009'
URBAN_MIN_MAX = (21, 30)
RURAL_MIN_MAX = (11, 13)

utils.config_logger()
logger = logging.getLogger(__name__)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('country_iso3',
                        help='Country ISO3')
    parser.add_argument('-d', '--download-ghs', action='store_true',
                        help='Download the GHS data')
    return parser.parse_args()


def main(country_iso3, download_ghs=False):

    # Get config file
    config = utils.parse_yaml(CONFIG_FILE)[country_iso3]

    # Get input boundary shape file
    input_dir = os.path.join(DIR_PATH, INPUT_DIR, country_iso3)
    input_shp = os.path.join(input_dir, SHAPEFILE_DIR, config['admin']['directory'],
                             f'{config["admin"]["directory"]}.shp')
    boundaries = gpd.read_file(input_shp).to_crs(GHS_CRS)

    # Download the tiles and read them in
    if download_ghs:
        get_ghs_data('SMOD', config['ghs'], country_iso3, input_dir)
        get_ghs_data('POP', config['ghs'], country_iso3, input_dir)
    ghs_smod = rasterio.open(os.path.join(input_dir, GHS_DIR,
                                          OUTPUT_GHS['SMOD'].format(country_iso3=country_iso3)))
    ghs_pop = rasterio.open(os.path.join(input_dir, GHS_DIR,
                                         OUTPUT_GHS['POP'].format(country_iso3=country_iso3)))

    # adding urban/rural disaggregation data using JRC GHSL input
    logger.info("Calculating urban population fraction")
    boundaries['frac_urban'] = boundaries['geometry'].apply(lambda x: calc_frac_urban(x, ghs_smod, ghs_pop))

    # Get food insecurity
    logger.info("Getting food insecurity")
    boundaries = add_food_insecurity(config['ipc'], input_dir, boundaries)

    # Get solid fuels
    if 'solid_fuels' in config:
        logger.info("Getting Solid Fuels data")
        boundaries = add_solid_fuels(boundaries, config['solid_fuels'])
    else:
        logger.info(f'Solid fuels data not available for country {country_iso3}')

    # Get raised blood pressure
    if 'raised_blood_pressure' in config:
        logger.info("Getting Raised Blood Pressure data")
        add_factor_18plus(boundaries, config['raised_blood_pressure'], 'raised_blood_pressure', country_iso3)
    else:
        logger.info(f'Raised blood pressure data not available for country {country_iso3}')

    # Get raised blood pressure
    if 'diabetes' in config:
        logger.info("Getting diabetes data")
        add_factor_18plus(boundaries, config['diabetes'], 'diabetes', country_iso3)
    else:
        logger.info(f'Diabetes data not available for country {country_iso3}')

    # Write out results
    output_dir = os.path.join(DIR_PATH, OUTPUT_DIR.format(country_iso3))
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    output_geojson = os.path.join(output_dir, OUTPUT_GEOJSON.format(country_iso3=country_iso3))
    logger.info(f"Saving results to {output_geojson}")
    utils.write_to_geojson(output_geojson, boundaries.to_crs(SHP_CRS))


def get_ghs_data(ghs_type, config, country_iso3, input_dir):
    """
    :param ghs_type: One of either "SMOD" or "POP"
    """
    logger.info(f'Getting GHS data for {ghs_type}')
    download_dir = os.path.join(input_dir, GHS_DIR, 'zip')
    Path(download_dir).mkdir(parents=True, exist_ok=True)
    for column, row in [ast.literal_eval(x) for x in config['column_row_pairs']]:
        zip_filename = os.path.join(download_dir, f'{ghs_type}_2015_1km_{column}_{row}.zip')
        utils.download_url(f'{GHS_URL_BASE}/{GHS_URL[ghs_type].format(column=column, row=row)}', zip_filename)
        utils.unzip(zip_filename, download_dir)
    # Make a mosaic
    files_to_mosaic = [rasterio.open(f) for f in glob.glob(os.path.join(download_dir, f'*_{ghs_type}_*.tif'))]
    logger.info(f'Making mosiac of {len(files_to_mosaic)} files')
    mosaic, out_trans = merge(files_to_mosaic)
    out_meta = files_to_mosaic[0].meta.copy()
    out_meta.update({"driver": "GTiff",
                     "height": mosaic.shape[1],
                     "width": mosaic.shape[2],
                     "transform": out_trans})
    output_filepath = os.path.join(input_dir, GHS_DIR,
                                   OUTPUT_GHS[ghs_type].format(country_iso3=country_iso3))
    with rasterio.open(output_filepath, "w", **out_meta) as dest:
        dest.write(mosaic)
    logger.info(f'Wrote file to {output_filepath}')


def calc_frac_urban(shape, ghs_smod, ghs_pop):
    pixels_smod = mask(ghs_smod, [shape])[0].flatten()
    pixels_pop = ghs_pop.read(1).flatten()
    pop_urban = sum(pixels_pop[np.where((pixels_smod >= URBAN_MIN_MAX[0]) & (pixels_smod <= URBAN_MIN_MAX[1]))])
    pop_rural = sum(pixels_pop[np.where((pixels_smod >= RURAL_MIN_MAX[0]) & (pixels_smod <= RURAL_MIN_MAX[1]))])
    return pop_urban / (pop_urban + pop_rural)


def add_food_insecurity(config, input_dir, boundaries):
    filename = os.path.join(input_dir, IPC_DIR, config['filename'])
    df_ipc = (pd.read_excel(filename, header=[11], skiprows=[12], nrows=45)
              .rename(columns={'Area': 'ADM1_EN', '#': 'Population', '%.5': 'Phase 3+'})
              .loc[:, ['ADM1_EN', 'Population', 'Phase 3+']]
              .replace({'Sari pul': 'Sar-e-Pul', 'Wardak': 'Maidan Wardak'}))
    # Make a data frame of just ADM1
    df_adm1 = pd.DataFrame(columns=['ADM1_EN', 'Phase 3+'])
    df_adm1['ADM1_EN'] = sorted(boundaries['ADM1_EN'].unique())
    # For each province, get the total insecurity, or the urban / rural if it's split
    for index, row in df_adm1.iterrows():
        adm1 = row['ADM1_EN']
        # Check if divided by urban / rural
        if f'{adm1} Urban' in list(df_ipc['ADM1_EN']):
            row_urban = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1} Urban'].iloc[0]
            row_rural = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1}'].iloc[0]
            phase_3 = (row_urban['Population'] * row_urban['Phase 3+'] +
                       row_rural['Population'] * row_rural['Phase 3+']) /\
                       (row_urban['Population'] + row_rural['Population'])
        else:
            phase_3 = df_ipc.loc[df_ipc['ADM1_EN'] == adm1, 'Phase 3+'].iloc[0]
        df_adm1.loc[index, 'Phase 3+'] = phase_3
    boundaries = boundaries.merge(df_adm1, on='ADM1_EN', how='left')
    return boundaries


def add_solid_fuels(boundaries, config):
    boundaries['solid_fuels'] = boundaries['frac_urban'].apply(lambda x: x * config['frac_urban'] +
                                                                        (1 - x) * config['frac_rural'])
    return boundaries


def add_factor_18plus(boundaries, fraction, factor_name, country_iso3):
    # TODO we could add disaggregation by gender
    try:
        exposure_gdf=gpd.read_file(get_output_filename(country_iso3) + 'test')
        # consider only 18+
        gender_age_groups=list(itertools.product(GENDER_CLASSES, [a for a in AGE_CLASSES if a > 18]))
        gender_age_group_names=['{}_{}'.format(gender_age_group[0], gender_age_group[1])\
            for gender_age_group in gender_age_groups]
        pop18_frac=exposure_gdf.loc[:,gender_age_group_names].sum(axis=1)/exposure_gdf['tot_sad']
        boundaries[factor_name]=pop18_frac*fraction
    except fiona.errors.DriverError:
        logger.info('Exposure data not available, cannot calculate fraction 18+')
    return boundaries


if __name__ == '__main__':
    args = parse_args()
    main(args.country_iso3.upper(), download_ghs=args.download_ghs)
