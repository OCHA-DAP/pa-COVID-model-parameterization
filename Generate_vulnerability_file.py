# script that pulls data from several sources and generate vulnerability breakdown for subnational SEIR model

import os
import glob
import argparse
import logging
from pathlib import Path
import ast

import numpy as np
import pandas as pd
import geopandas as gpd
import rasterio
from rasterio.merge import merge
from rasterio.mask import mask

import utils

INPUT_DIR = 'Inputs'
OUTPUT_DIR = os.path.join('Outputs', '{}', 'Vulnerability')
OUTPUT_GEOJSON = '{country_iso3}_Vulnerabilities.geojson'
CONFIG_FILE = 'config.yml'
DIR_PATH = os.path.dirname(os.path.realpath(__file__))

# Shape stuff
SHAPEFILE_DIR = 'Shapefiles'
SHP_CRS = 'EPSG:4326'

# IPC
IPC_DIR = 'IPC'

# GHS data
GHS_DIR = 'GHS'
GHS_URL_BASE = 'https://cidportal.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL'
GHS_URL = {'SMOD': 'GHS_SMOD_POP_GLOBE_R2019A/GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K/V2-0/tiles/'
                   'GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K_V2_0_{column}_{row}.zip',
           'POP': 'GHS_POP_MT_GLOBE_R2019A/GHS_POP_E2015_GLOBE_R2019A_54009_1K/V1-0/tiles/'
                  'GHS_POP_E2015_GLOBE_R2019A_54009_1K_V1_0_{column}_{row}.zip'
           }
OUTPUT_GHS = {
    'SMOD':  '{country_iso3}_SMOD_2015_1km_mosaic.tif',
    'POP': '{country_iso3}_POP_2015_1km_mosaic.tif'
}
GHS_CRS = 'ESRI:54009'
URBAN_MIN_MAX = (21, 30)
RURAL_MIN_MAX = (11, 13)

utils.config_logger()
logger = logging.getLogger(__name__)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('country_iso3',
                        help='Country ISO3')
    parser.add_argument('-d', '--download-ghs', action='store_true',
                        help='Download the GHS data')
    return parser.parse_args()


def main(country_iso3, download_ghs=False):

    # Get config file
    config = utils.parse_yaml(CONFIG_FILE)[country_iso3]

    # Get input boundary shape file
    input_dir = os.path.join(DIR_PATH, INPUT_DIR, country_iso3)
    input_shp = os.path.join(input_dir, SHAPEFILE_DIR, config['admin']['directory'], config['admin']['filename'])
    boundaries = gpd.read_file(input_shp).to_crs(GHS_CRS)

    # Download the tiles and read them in
    if download_ghs:
        get_ghs_data('SMOD', config['ghs'], country_iso3, input_dir)
        get_ghs_data('POP', config['ghs'], country_iso3, input_dir)
    ghs_smod = rasterio.open(os.path.join(input_dir, GHS_DIR,
                                          OUTPUT_GHS['SMOD'].format(country_iso3=country_iso3)))
    ghs_pop = rasterio.open(os.path.join(input_dir, GHS_DIR,
                                         OUTPUT_GHS['POP'].format(country_iso3=country_iso3)))

    # adding urban/rural disaggregation data using JRC GHSL input
    logger.info("Calculating urban population fraction")
    boundaries['frac_urban'] = boundaries['geometry'].apply(lambda x: calc_frac_urban(x, ghs_smod, ghs_pop))

    # Get food insecurity
    logger.info("Getting food insecurity")
    boundaries = add_food_insecurity(config['ipc'], input_dir, boundaries)

    # Write out results
    output_dir = OUTPUT_DIR.format(country_iso3)
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    output_geojson = os.path.join(output_dir, OUTPUT_GEOJSON.format(country_iso3=country_iso3))
    logger.info(f"Saving results to {output_geojson}")
    boundaries.to_crs(SHP_CRS).to_file(output_geojson, driver='GeoJSON')


def get_ghs_data(ghs_type, config, country_iso3, input_dir):
    """
    :param ghs_type: One of either "SMOD" or "POP"
    """
    logger.info(f'Getting GHS data for {ghs_type}')
    download_dir = os.path.join(GHS_DIR, 'zip')
    Path(download_dir).mkdir(parents=True, exist_ok=True)
    for column, row in [ast.literal_eval(x) for x in config['column_row_pairs']]:
        zip_filename = os.path.join(download_dir, f'{ghs_type}_2015_1km_{column}_{row}.zip')
        utils.download_url(f'{GHS_URL_BASE}/{GHS_URL[ghs_type].format(column=column, row=row)}', zip_filename)
        utils.unzip(zip_filename, download_dir)
    # Make a mosaic
    files_to_mosaic = [rasterio.open(f) for f in glob.glob(os.path.join(download_dir, f'*_{ghs_type}_*.tif'))]
    logger.info(f'Making mosiac of {len(files_to_mosaic)} files')
    mosaic, out_trans = merge(files_to_mosaic)
    out_meta = files_to_mosaic[0].meta.copy()
    out_meta.update({"driver": "GTiff",
                     "height": mosaic.shape[1],
                     "width": mosaic.shape[2],
                     "transform": out_trans})
    output_filepath = os.path.join(input_dir, GHS_DIR,
                                   OUTPUT_GHS[ghs_type].format(country_iso3=country_iso3))
    with rasterio.open(output_filepath, "w", **out_meta) as dest:
        dest.write(mosaic)
    logger.info(f'Wrote file to {output_filepath}')


def calc_frac_urban(shape, ghs_smod, ghs_pop):
    pixels_smod = mask(ghs_smod, [shape])[0].flatten()
    pixels_pop = ghs_pop.read(1).flatten()
    pop_urban = sum(pixels_pop[np.where((pixels_smod >= URBAN_MIN_MAX[0]) & (pixels_smod <= URBAN_MIN_MAX[1]))])
    pop_rural = sum(pixels_pop[np.where((pixels_smod >= RURAL_MIN_MAX[0]) & (pixels_smod <= RURAL_MIN_MAX[1]))])
    return pop_urban / (pop_urban + pop_rural)


def add_food_insecurity(config, input_dir, boundaries):
    filename = os.path.join(input_dir, IPC_DIR, config['filename'])
    df_ipc = (pd.read_excel(filename, header=[11], skiprows=[12], nrows=45)
              .rename(columns={'Area': 'ADM1_EN', '#': 'Population', '%.5': 'Phase 3+'})
              .loc[:, ['ADM1_EN', 'Population', 'Phase 3+']]
              .replace({'Sari pul': 'Sar-e-Pul', 'Wardak': 'Maidan Wardak'}))
    # Make a data frame of just ADM1
    df_adm1 = pd.DataFrame(columns=['ADM1_EN', 'Phase 3+'])
    df_adm1['ADM1_EN'] = sorted(boundaries['ADM1_EN'].unique())
    # For each province, get the total insecurity, or the urban / rural if it's split
    for index, row in df_adm1.iterrows():
        adm1 = row['ADM1_EN']
        # Check if divided by urban / rural
        if f'{adm1} Urban' in list(df_ipc['ADM1_EN']):
            row_urban = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1} Urban'].iloc[0]
            row_rural = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1}'].iloc[0]
            phase_3 = (row_urban['Population'] * row_urban['Phase 3+'] +
                       row_rural['Population'] * row_rural['Phase 3+']) /\
                       (row_urban['Population'] + row_rural['Population'])
        else:
            phase_3 = df_ipc.loc[df_ipc['ADM1_EN'] == adm1, 'Phase 3+'].iloc[0]
        df_adm1.loc[index, 'Phase 3+'] = phase_3
    boundaries = boundaries.merge(df_adm1, on='ADM1_EN', how='left')
    return boundaries


if __name__ == '__main__':
    args = parse_args()
    main(args.country_iso3.upper(), download_ghs=args.download_ghs)
