# script that pulls data from several sources and generate vulnerability breakdown for subnational SEIR model

import os
import glob
import argparse

import numpy as np
import pandas as pd
import geopandas as gpd
import rasterio
from rasterio.merge import merge
from rasterio.mask import mask
import itertools

import utils

INPUT_DIR = 'Inputs'
OUTPUT_DIR = 'Outputs'

# input shapefile downloaded from https://data.humdata.org/dataset/afg-admin-boundaries
INPUT_SHP = 'Inputs/Shapefiles/afg_admbnda_adm2_agcho_20180522/afg_admbnda_adm2_agcho_20180522.shp'
OUTPUT_SHP = 'Outputs/Vulnerability/AFG_Vulnerabilities.shp'
EXPOSURE_SHP = 'Outputs/Exposure_SADD/AFG_Exposure.shp'
SHP_CRS = 'EPSG:4326'
dir_path = os.path.dirname(os.path.realpath(__file__))
country_iso3='AFG'

# GHS data
GHS_URL_BASE = 'https://cidportal.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL'
GHS_URL = {'SMOD': 'GHS_SMOD_POP_GLOBE_R2019A/GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K/V2-0/tiles/'
                   'GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K_V2_0_{column}_{row}.zip',
           'POP': 'GHS_POP_MT_GLOBE_R2019A/GHS_POP_E2015_GLOBE_R2019A_54009_1K/V1-0/tiles/'
                  'GHS_POP_E2015_GLOBE_R2019A_54009_1K_V1_0_{column}_{row}.zip'
           }
COLUMN_ROW_PAIRS = [(23, 4), (23, 5), (24, 4), (24, 5)]
GHS_DIR = os.path.join(INPUT_DIR, 'GHS')
OUTPUT_GHS = {
    'SMOD':  'SMOD_2015_1km_mosaic.tif',
    'POP': 'POP_2015_1km_mosaic.tif'
}
GHS_CRS = 'ESRI:54009'
URBAN_MIN_MAX = (21, 30)
RURAL_MIN_MAX = (11, 13)

# IPC Data
IPC_FILE = 'Inputs/IPC/Afghanistan - IPC Analysis 2020-2020.xlsx'


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-g', '--download-ghs', action='store_true',
                        help='Download the GHS data')
    return parser.parse_args()


def main(download_ghs=False):
    # Download the tiles
    if download_ghs:
        get_ghs_data('SMOD')
        get_ghs_data('POP')
    ghs_smod = rasterio.open(os.path.join(GHS_DIR, OUTPUT_GHS['SMOD']))
    ghs_pop = rasterio.open(os.path.join(GHS_DIR, OUTPUT_GHS['POP']))
    boundaries = gpd.read_file('{}/{}'.format(dir_path,INPUT_SHP)).to_crs(GHS_CRS)
    # adding urban/rural disaggregation data using JRC GHSL input
    print("Calculating urban population fraction")
    boundaries['frac_urban'] = boundaries['geometry'].apply(lambda x: calc_frac_urban(x, ghs_smod, ghs_pop))
    # Get food insecurity
    print("Getting food insecurity")
    boundaries = add_food_insecurity(boundaries)
    # Get solid fuels
    print("Getting Solid Fuels data")
    boundaries = add_solid_fuels(boundaries,country_iso3)
    # Get raised blood pressure
    print("Getting Raised Blood Pressure data")
    boundaries = add_raised_blood_pressure(boundaries,country_iso3)
    
    # Write out results
    print(f"Saving results to {OUTPUT_SHP}")
    boundaries.to_crs(SHP_CRS).to_file(OUTPUT_SHP)


def get_ghs_data(ghs_type):
    """
    :param ghs_type: One of either "SMOD" or "POP"
    """
    print(f'Getting GHS data for {ghs_type}')
    download_dir = os.path.join(GHS_DIR, 'zip')
    for column, row in COLUMN_ROW_PAIRS:
        zip_filename = os.path.join(download_dir, f'{ghs_type}_2015_1km_{column}_{row}.zip')
        utils.download_url(f'{GHS_URL_BASE}/{GHS_URL[ghs_type].format(column=column, row=row)}', zip_filename)
        utils.unzip(zip_filename, download_dir)
    # Make a mosaic
    files_to_mosaic = [rasterio.open(f) for f in glob.glob(os.path.join(download_dir, f'*_{ghs_type}_*.tif'))]
    print(f'Making mosiac of {len(files_to_mosaic)} files')
    mosaic, out_trans = merge(files_to_mosaic)
    out_meta = files_to_mosaic[0].meta.copy()
    out_meta.update({"driver": "GTiff",
                     "height": mosaic.shape[1],
                     "width": mosaic.shape[2],
                     "transform": out_trans})
    output_filepath = os.path.join(GHS_DIR, OUTPUT_GHS[ghs_type])
    with rasterio.open(output_filepath, "w", **out_meta) as dest:
        dest.write(mosaic)
    print(f'Wrote file to {output_filepath}')


def calc_frac_urban(shape, ghs_smod, ghs_pop):
    pixels_smod = mask(ghs_smod, [shape])[0].flatten()
    pixels_pop = ghs_pop.read(1).flatten()
    pop_urban = sum(pixels_pop[np.where((pixels_smod >= URBAN_MIN_MAX[0]) & (pixels_smod <= URBAN_MIN_MAX[1]))])
    pop_rural = sum(pixels_pop[np.where((pixels_smod >= RURAL_MIN_MAX[0]) & (pixels_smod <= RURAL_MIN_MAX[1]))])
    return pop_urban / (pop_urban + pop_rural)


def add_food_insecurity(boundaries):
    df_ipc = (pd.read_excel(IPC_FILE, header=[11], skiprows=[12], nrows=45)
              .rename(columns={'Area': 'ADM1_EN', '#': 'Population', '%.5': 'Phase 3+'})
              .loc[:, ['ADM1_EN', 'Population', 'Phase 3+']]
              .replace({'Sari pul': 'Sar-e-Pul', 'Wardak': 'Maidan Wardak'}))
    # Make a data frame of just ADM1
    df_adm1 = pd.DataFrame(columns=['ADM1_EN', 'Phase 3+'])
    df_adm1['ADM1_EN'] = sorted(boundaries['ADM1_EN'].unique())
    # For each province, get the total insecurity, or the urban / rural if it's split
    for index, row in df_adm1.iterrows():
        adm1 = row['ADM1_EN']
        # Check if divided by urban / rural
        if f'{adm1} Urban' in list(df_ipc['ADM1_EN']):
            row_urban = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1} Urban'].iloc[0]
            row_rural = df_ipc.loc[df_ipc['ADM1_EN'] == f'{adm1}'].iloc[0]
            phase_3 = (row_urban['Population'] * row_urban['Phase 3+'] +
                       row_rural['Population'] * row_rural['Phase 3+']) /\
                       (row_urban['Population'] + row_rural['Population'])
        else:
            phase_3 = df_ipc.loc[df_ipc['ADM1_EN'] == adm1, 'Phase 3+'].iloc[0]
        df_adm1.loc[index, 'Phase 3+'] = phase_3
    boundaries = boundaries.merge(df_adm1, on='ADM1_EN', how='left')
    return boundaries

def add_solid_fuels(boundaries,iso3):
    if(iso3=='AFG'):
        # from https://apps.who.int/gho/data/node.main.135?lang=en
        solid_fuels_frac_urban=28
        solid_fuels_frac_rural=95
    else:
        print('Solid fuels data not available for country {}'.format(iso3))
    for index, row in boundaries.iterrows():
        frac_urban=row['frac_urban']
        boundaries.loc[index,'solid_fuels']=frac_urban*solid_fuels_frac_urban+\
            (1-frac_urban)*solid_fuels_frac_rural
    return boundaries

def add_solid_fuels(boundaries,iso3):
    if(iso3=='AFG'):
        # from https://apps.who.int/gho/data/node.main.135?lang=en
        solid_fuels_frac_urban=0.28
        solid_fuels_frac_rural=0.95
    else:
        print('Solid fuels data not available for country {}'.format(iso3))
        return boundaries
    for index, row in boundaries.iterrows():
        frac_urban=row['frac_urban']
        boundaries.loc[index,'solid_fuels']=frac_urban*solid_fuels_frac_urban+\
            (1-frac_urban)*solid_fuels_frac_rural
    return boundaries

def add_raised_blood_pressure(boundaries,iso3):
    if(iso3=='AFG'):
        # https://www.who.int/nmh/countries/afg_en.pdf?ua=1
        raised_blood_pressure=0.23
    else:
        print('Raised blood pressure data not available for country {}'.format(iso3))
        return boundaries
    # try:
    exposure_gdf=gpd.read_file('{}/{}'.format(dir_path,EXPOSURE_SHP))
    print(exposure_gdf.columns)
    # consider 18+
    gender_classes=["f","m"]
    age_classes=[20,25,30,35,40,45,50,55,60,65,70,75,80]
    gender_age_groups=list(itertools.product(gender_classes,age_classes))
    gender_age_group_names=['{}_{}'.format(gender_age_group[0],gender_age_group[1])\
         for gender_age_group in gender_age_groups]

    pop18_frac=exposure_gdf.loc[:,gender_age_group_names].sum(axis=1)/exposure_gdf['tot_sad']
    boundaries['raised_blood_pressure_frac']=pop18_frac*raised_blood_pressure
    return boundaries
    # except Exception:
    #     print('Exposure data not available, cannot calculate fraction 18+')
    #     return boundaries




if __name__ == '__main__':
    args = parse_args()
    main(download_ghs=args.download_ghs)
