# script that pulls data from several sources and generate vulnerability breakdown for subnational SEIR model

import os
import glob
import argparse

import numpy as np
import geopandas as gpd
import rasterio
from rasterio.merge import merge
from rasterio.mask import mask

import utils

INPUT_DIR = 'Inputs'
OUTPUT_DIR = 'Outputs'

# input shapefile downloaded from https://data.humdata.org/dataset/afg-admin-boundaries
INPUT_SHP = 'Inputs/Shapefiles/afg_admbnda_adm2_agcho_20180522/afg_admbnda_adm2_agcho_20180522.shp'
OUTPUT_SHP = 'Outputs/Vulnerability/AFG_Vulnerabilities.shp'
dir_path = os.path.dirname(os.path.realpath(__file__))

# GHS DATA
GHS_URL_BASE = 'https://cidportal.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL'
GHS_URL = {'SMOD': 'GHS_SMOD_POP_GLOBE_R2019A/GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K/V2-0/tiles/'
                   'GHS_SMOD_POP2015_GLOBE_R2019A_54009_1K_V2_0_{column}_{row}.zip',
           'POP': 'GHS_POP_MT_GLOBE_R2019A/GHS_POP_E2015_GLOBE_R2019A_54009_1K/V1-0/tiles/'
                  'GHS_POP_E2015_GLOBE_R2019A_54009_1K_V1_0_{column}_{row}.zip'
           }
COLUMN_ROW_PAIRS = [(23, 4), (23, 5), (24, 4), (24, 5)]
GHS_DIR = os.path.join(INPUT_DIR, 'GHS')
OUTPUT_GHS = {
    'SMOD':  'SMOD_2015_1km_mosaic.tif',
    'POP': 'POP_2015_1km_mosaic.tif'
}
GHS_CRS = 'ESRI:54009'
URBAN_MIN_MAX = (21, 30)
RURAL_MIN_MAX = (11, 13)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-g', '--download-ghs', action='store_true',
                        help='Download the GHS data')
    return parser.parse_args()


def main(download_ghs=False):
    # Download the tiles
    if download_ghs:
        get_ghs_data('SMOD')
        get_ghs_data('POP')
    ghs_smod = rasterio.open(os.path.join(GHS_DIR, OUTPUT_GHS['SMOD']))
    ghs_pop = rasterio.open(os.path.join(GHS_DIR, OUTPUT_GHS['POP']))
    boundaries = gpd.read_file('{}/{}'.format(dir_path,INPUT_SHP)).to_crs(GHS_CRS)
    # adding urban/rural disaggregation data using JRC GHSL input
    print("Calculating urban population fraction")
    boundaries['frac_urban'] = boundaries['geometry'].apply(lambda x: calc_frac_urban(x, ghs_smod, ghs_pop))
    # Write out results
    print(f"Saving results to {OUTPUT_SHP}")
    boundaries.to_file(OUTPUT_SHP)


def get_ghs_data(ghs_type):
    """
    :param ghs_type: One of either "SMOD" or "POP"
    """
    print(f'Getting GHS data for {ghs_type}')
    download_dir = os.path.join(GHS_DIR, 'zip')
    for column, row in COLUMN_ROW_PAIRS:
        zip_filename = os.path.join(download_dir, f'{ghs_type}_2015_1km_{column}_{row}.zip')
        utils.download_url(f'{GHS_URL_BASE}/{GHS_URL[ghs_type].format(column=column, row=row)}', zip_filename)
        utils.unzip(zip_filename, download_dir)
    # Make a mosaic
    files_to_mosaic = [rasterio.open(f) for f in glob.glob(os.path.join(download_dir, f'*_{ghs_type}_*.tif'))]
    print(f'Making mosiac of {len(files_to_mosaic)} files')
    mosaic, out_trans = merge(files_to_mosaic)
    out_meta = files_to_mosaic[0].meta.copy()
    out_meta.update({"driver": "GTiff",
                     "height": mosaic.shape[1],
                     "width": mosaic.shape[2],
                     "transform": out_trans})
    output_filepath = os.path.join(GHS_DIR, OUTPUT_GHS[ghs_type])
    with rasterio.open(output_filepath, "w", **out_meta) as dest:
        dest.write(mosaic)
    print(f'Wrote file to {output_filepath}')


def calc_frac_urban(shape, ghs_smod, ghs_pop):
    pixels_smod = mask(ghs_smod, [shape])[0].flatten()
    pixels_pop = ghs_pop.read(1).flatten()
    pop_urban = sum(pixels_pop[np.where((pixels_smod >= URBAN_MIN_MAX[0]) & (pixels_smod <= URBAN_MIN_MAX[1]))])
    pop_rural = sum(pixels_pop[np.where((pixels_smod >= RURAL_MIN_MAX[0]) & (pixels_smod <= RURAL_MIN_MAX[1]))])
    return pop_urban / (pop_urban + pop_rural)


if __name__ == '__main__':
    args = parse_args()
    main(download_ghs=args.download_ghs)
